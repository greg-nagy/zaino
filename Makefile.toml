env_files = [".env.testing-artifacts"]

[config]
default_to_workspace = false

[env]
IMAGE_NAME = "zingodevops/zaino-ci"
TEST_BINARIES_DIR = "/home/container_user/zaino/test_binaries/bins"

[tasks.help]
description = "List available commands and usage notes"
script_runner = "bash"
extend = "base-script"
script.main = '''
set -euo pipefail

echo ""
echo "Zaino CI Image Tasks"
echo "---------------------"
echo ""
echo "Common usage:"
echo "  makers container-test"
echo ""
echo "If you modify '.env.testing-artifacts', the test command will automatically:"
echo "  - Recompute the image tag"
echo "  - Build a new local Docker image if needed"
echo ""
echo "Available commands:"
echo ""
echo "  container-test             Run integration tests using the local image"
echo "  build-image                Build the Docker image with current artifact versions"
echo "  push-image                 Push the image (used in CI, can be used manually)"
echo "  compute-image-tag          Compute the tag for the Docker image based on versions"
echo "  update-docker-hash         Update DOCKER_DIR_HASH if test_environment has changed"
echo "  ensure-image-exists        Check if the required image exists locally, build if not"
echo "  check-matching-zebras      Verify Zebra versions match between Cargo.toml and .env"
echo "  validate-makefile-tasks    Run minimal validation of all maker tasks"
echo "  hello-rust                 Test rust-script functionality"
echo ""
echo "Environment:"
echo "  Defined by: .env.testing-artifacts"
echo "  Affects:    RUST_VERSION, ZCASH_VERSION, ZEBRA_VERSION"
echo ""
echo "Build Context:"
echo "  test_environment/          Directory containing the Docker build environment"
echo "    ├── Dockerfile          Dockerfile for CI/test container"
echo "    └── entrypoint.sh       Entrypoint script that sets up test binaries"
echo ""
echo "Helpers:"
echo "  - utils/get-ci-image-tag.sh: computes the version-based image tag"
echo "  - utils/helpers.sh: logging and helper functions"
echo ""
'''

[tasks.base-script]
script.pre = '''
source "./utils/helpers.sh"
TAG=$(./utils/get-ci-image-tag.sh)

# Generic cleanup function for docker containers
docker_cleanup() {
    # Prevent running cleanup twice
    if [ "${CLEANUP_RAN:-0}" -eq 1 ]; then
        return
    fi
    CLEANUP_RAN=1

    # Check if we're cleaning up due to interruption
    if [ "$?" -eq 130 ] || [ "$?" -eq 143 ]; then
        echo ""
        warn "Task '${CARGO_MAKE_CURRENT_TASK_NAME}' interrupted! Cleaning up..."
    fi

    # Kill all child processes
    local pids=$(jobs -pr)
    if [ -n "$pids" ]; then
        kill $pids 2>/dev/null || true
    fi

    # Stop any docker containers started by this script
    if [ -n "${CONTAINER_ID:-}" ]; then
        info "Stopping Docker container..."
        docker stop "$CONTAINER_ID" >/dev/null 2>&1 || true
    fi

    # Also stop by name if CONTAINER_NAME is set
    if [ -n "${CONTAINER_NAME:-}" ] && [ -z "${CONTAINER_ID:-}" ]; then
        info "Stopping Docker container ${CONTAINER_NAME}..."
        docker stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
    fi
}

# Set up cleanup trap
trap docker_cleanup EXIT INT TERM
'''
script.main = "err 'default main script. define a proper script to skip this one'"
script.post = ""

# -------------------------------------------------------------------

[tasks.init-docker-volumes]
description = "Initialize Docker volume directories with proper permissions"
script = '''
# Check if directories exist with wrong permissions
if [ -d "container-target" ] && [ ! -w "container-target" ]; then
    echo "WARNING: container-target exists but is not writable by current user."
    echo "You may need to run: sudo chown -R $(id -u):$(id -g) container-target"
    echo "Or remove it with: sudo rm -rf container-target"
fi

# Create directories if they don't exist
# Docker will respect the ownership if directories already exist
for dir in container-target docker_cargo/git docker_cargo/registry; do
    if [ ! -d "$dir" ]; then
        mkdir -p "$dir"
        echo "Created directory: $dir"
    fi
done

# Set permissions to ensure they're accessible
chmod -R 755 container-target docker_cargo 2>/dev/null || true
'''

# -------------------------------------------------------------------

[tasks.compute-image-tag]
description = "Compute image tag from version vars"
script = '''
TAG=$(./utils/get-ci-image-tag.sh)
echo "CARGO_MAKE_IMAGE_TAG=$TAG"
export CARGO_MAKE_IMAGE_TAG=$TAG
'''
# -------------------------------------------------------------------

[tasks.update-docker-hash]
description = "Update DOCKER_DIR_HASH in .env.testing-artifacts if test_environment has changed"
script_runner = "bash"
script = '''
set -euo pipefail

# Get the current hash from HEAD
CURRENT_HASH=$(git ls-tree HEAD test_environment | git hash-object --stdin | cut -c1-14)

# Get the hash from .env.testing-artifacts
if [ -f .env.testing-artifacts ]; then
    ENV_HASH=$(grep "^DOCKER_DIR_HASH=" .env.testing-artifacts | cut -d'=' -f2)
else
    echo "ERROR: .env.testing-artifacts not found!"
    exit 1
fi

# Compare and update if different
if [ "$CURRENT_HASH" != "$ENV_HASH" ]; then
    echo "test_environment has changed. Updating DOCKER_DIR_HASH from $ENV_HASH to $CURRENT_HASH"

    # Update the file
    sed -i.bak "s/^DOCKER_DIR_HASH=.*/DOCKER_DIR_HASH=$CURRENT_HASH/" .env.testing-artifacts
    rm -f .env.testing-artifacts.bak

    echo "Updated .env.testing-artifacts with new DOCKER_DIR_HASH: $CURRENT_HASH"
    echo "Note: You should commit this change to .env.testing-artifacts"
else
    echo "DOCKER_DIR_HASH is up to date: $CURRENT_HASH"
fi
'''

[tasks.ensure-image-exists]
description = "Ensure the image exists locally or on Docker Hub before building"
# This task checks if the required Docker image exists locally or on Docker Hub.
# If not found, it triggers the build-image task to build from test_environment.
dependencies = ["init-docker-volumes", "update-docker-hash"]
extend = "base-script"
script.main = '''
# Re-source the environment file and recompute TAG in case update-docker-hash changed it
source "${CARGO_MAKE_WORKING_DIRECTORY}/.env.testing-artifacts"
export RUST_VERSION ZCASH_VERSION ZEBRA_VERSION DOCKER_DIR_HASH
TAG=$("${CARGO_MAKE_WORKING_DIRECTORY}/utils/get-ci-image-tag.sh")

if ! docker image inspect ${IMAGE_NAME}:${TAG} > /dev/null 2>&1; then
  warn "Image not found locally. Attempting to pull from Docker Hub..."
  if docker pull ${IMAGE_NAME}:${TAG}; then
    info "Image ${IMAGE_NAME}:${TAG} pulled successfully."
  else
    warn "Image not found on Docker Hub. Building image..."
    makers build-image
  fi
else
  info "Image ${IMAGE_NAME}:${TAG} already exists locally."
fi
'''

# -------------------------------------------------------------------

[tasks.build-image]
description = "Build the Docker image for testing artifacts"
# Note: This task builds the Docker image from the test_environment directory,
# which contains the Dockerfile and entrypoint.sh for the CI/test environment.
# The build context is set to test_environment to keep paths simple.
dependencies = ["update-docker-hash"]
script_runner = "bash"
extend = "base-script"
script.main = '''
# Re-source the environment file to get the updated hash
source "${CARGO_MAKE_WORKING_DIRECTORY}/.env.testing-artifacts"
export RUST_VERSION ZCASH_VERSION ZEBRA_VERSION DOCKER_DIR_HASH
TAG=$("${CARGO_MAKE_WORKING_DIRECTORY}/utils/get-ci-image-tag.sh")
set -euo pipefail

# Create target directory with correct ownership before Docker creates it as root
mkdir -p target

TARGET=$(resolve_build_target "$ZCASH_VERSION" "$ZEBRA_VERSION")

# For local builds, use the current user's UID/GID to avoid permission issues
# CI builds will use the default UID=1001 from the Dockerfile

info "Building image"
info "Tag: ${TAG}"
info "Target: $TARGET"
info "Current directory: $(pwd)"
info "Files in utils/: $(ls -la utils/ | head -5)"

cd test_environment && \
docker build -f Dockerfile \
  --target "$TARGET" \
  --build-arg ZCASH_VERSION=$ZCASH_VERSION \
  --build-arg ZEBRA_VERSION=$ZEBRA_VERSION \
  --build-arg RUST_VERSION=$RUST_VERSION \
  --build-arg UID=$(id -u) \
  --build-arg GID=$(id -g) \
  -t ${IMAGE_NAME}:$TAG \
  ${@} \
  .
'''

# -------------------------------------------------------------------

[tasks.push-image]
description = "Push image if running in CI"
# condition = { env_set = ["CI"] }
dependencies = ["update-docker-hash"]
script_runner = "bash"
extend = "base-script"
script.main = '''
# Re-source the environment file to get the updated hash
source "${CARGO_MAKE_WORKING_DIRECTORY}/.env.testing-artifacts"
export RUST_VERSION ZCASH_VERSION ZEBRA_VERSION DOCKER_DIR_HASH
TAG=$("${CARGO_MAKE_WORKING_DIRECTORY}/utils/get-ci-image-tag.sh")
set -euo pipefail

info "Pushing image: ${IMAGE_NAME}:$TAG"

docker push ${IMAGE_NAME}:$TAG
'''

# -------------------------------------------------------------------

[tasks.container-test]
clear = true
description = "Run integration tests using the local image"
# This task runs tests inside the Docker container built from test_environment.
# The entrypoint.sh script in the container sets up test binaries (zcashd, zebrad, zcash-cli)
# by creating symlinks from /home/container_user/artifacts to the expected test_binaries/bins location.
dependencies = ["init-docker-volumes", "ensure-image-exists"]
script_runner = "bash"
extend = "base-script"
script.main = '''
set -euo pipefail

info "Running tests using:"
info "-- IMAGE             = ${IMAGE_NAME}"
info "-- TAG               = $TAG"
# info "-- TEST_BINARIES_DIR = ${TEST_BINARIES_DIR}"

# Create directories with correct ownership before Docker creates them as root
mkdir -p container-target docker_cargo/git docker_cargo/registry

# Set container name for cleanup
CONTAINER_NAME="zaino-testing"

# Run docker in foreground with proper signal handling
docker run --rm \
  --init \
  --name "$CONTAINER_NAME" \
  -v "$PWD":/home/container_user/zaino \
  -v "$PWD/container-target":/home/container_user/zaino/target \
  -v "$PWD/docker_cargo/git":/home/container_user/.cargo/git \
  -v "$PWD/docker_cargo/registry":/home/container_user/.cargo/registry \
  -e "TEST_BINARIES_DIR=${TEST_BINARIES_DIR}" \
  -e "CARGO_TARGET_DIR=/home/container_user/zaino/target" \
  -w /home/container_user/zaino \
  -u container_user \
  "${IMAGE_NAME}:$TAG" \
  cargo nextest run --profile ci "${@}" &

# Capture the background job PID
DOCKER_PID=$!

# Wait for the docker process
wait $DOCKER_PID
'''

# -------------------------------------------------------------------

[tasks.check-matching-zebras]
description = "Check that zebra versions in .env.testing-artifacts match what's in Cargo.toml"
extend = "base-script"
script_runner = "bash"
script.main = '''
set -euo pipefail

# source .env.testing-artifacts

# Normalize Cargo.toml (stripping comments, whitespace)
cargo_toml=$(sed 's/#.*//' Cargo.toml | tr -d '[:space:]')

# Check Zebra rev
zebra_revs=$(echo "$cargo_toml" | grep -o 'zebra-[a-z]*={[^}]*rev="[^"]*"' | grep -o 'rev="[^"]*"' | cut -d'"' -f2 | sort -u)

if [[ $(echo "$zebra_revs" | wc -l) -ne 1 ]]; then
  err "❌ Multiple Zebra revs detected in Cargo.toml:"
  echo "$zebra_revs"
  exit 1
fi

actual_rev="$zebra_revs"

# Accept short SHA from env if it matches prefix of actual
if [[ "$actual_rev" != "$ZEBRA_VERSION" && "${actual_rev:0:${#ZEBRA_VERSION}}" != "$ZEBRA_VERSION" ]]; then
  err "❌ Mismatch for Zebra git rev: Cargo.toml has $actual_rev, but .env.testing-artifacts has $ZEBRA_VERSION"
  exit 1
fi

info "✅ All versions match between Cargo.toml and .env.testing-artifacts"
'''

# -------------------------------------------------------------------

[tasks.doc]
description = "Run `cargo doc`"
script = '''
RUSTDOCFLAGS="-D warnings" cargo doc --no-deps --document-private-items
'''
